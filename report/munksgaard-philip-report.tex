\documentclass[a4paper, 12pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
%\usepackage[top=3cm,left=3cm]{geometry}

\usepackage{fancyhdr}  % page headers
\usepackage{graphicx}  % \includegraphics
\usepackage{xcolor}    % \definecolor
\usepackage{colortbl}  % for colouring tables
\usepackage{cite}      % \cite formatting
\usepackage{url}       % \hyperref, \url, \href
\usepackage{hyperref}  % references become hyperlinks
\usepackage{mathtools} % amsmath++
\usepackage{tikz}      % graphs
\usepackage{epsfig}    % .epsi graphics
\usepackage{subcaption}

\usepackage{microtype} % better linebreaking
\usepackage{eso-pic}   % alternative to ku-forside
%\usepackage{libertine} % nice regular font
\usepackage[scaled=0.9]{inconsolata} % nice teletype font
\usepackage{array}     % extensible array, tabular
%\usepackage{parskip}   % paragraphs

\usepackage{fancyvrb}  % Use verbatim as: !this!
\DefineShortVerb{\!}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code excerpts
\usepackage{listings}

\definecolor{Brown}{cmyk}{0,0.81,1,0.60}
\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{CadetBlue}{cmyk}{0.62,0.57,0.23,0}
\definecolor{lightlightgray}{gray}{0.9}

\lstset{ %
  backgroundcolor=\color{lightlightgray},
  basicstyle=\scriptsize\ttfamily,
  breakatwhitespace=false,
  breaklines=false,
  language=matlab,
  deletekeywords={mean},
  morekeywords={rep, seq, rnorm, cbind},
  escapeinside={\%*}{*)}, % add LaTeX code inside code. example: val x%*$_1$*) = 42
  extendedchars=true,
  frame=none,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{gray},
  commentstyle=\color{gray},
  keywordstyle=\color{OliveGreen},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=1,
  tabsize=4,
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\setlength\parskip{1em}
%\setlength{\parindent}{0pt}
\def\arraystretch{2}

\title{
  \vspace{5em}
  Principles of Computer Systems Design \\
  Final Exam
}

\author{%
  \begin{tabular}{l l l}
    Philip Munksgaard & 1989-07-24 & pmunksgaard@gmail.com
  \end{tabular}
}

\date{\today}

\begin{document}

\AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]{ku-farve}}}
\AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]{ku-farve}}}
\AddToShipoutPicture*{\put(0,0){\includegraphics*{nat-en}}}

\clearpage
\maketitle

\thispagestyle{empty}

\newpage

\fancyhead[LO,RE]{Philip Munksgaard}
\fancyhead[LE,RO]{PCSD, Final Exam \\ \today }
\pagestyle{fancy}

\section*{Programming Part}

\subsection*{Question 1 - Implementation}

%% Overall implementation of OrderManager and ItemSupplier, including
%% the following:

%% - Considering your use of logging, what RPC semantics are
%% effectively implemented between clients and OrderManager or
%% ItemSupplier? What RPC semantics are effectively implemented
%% between OrderManager and ItemSupplier? Explain.

%% - How did you make workflow processing asynchronous at the
%% OrderManager?

%% - How did you handle failures of individual components? In
%% particular, how do you handle failure propagation?

The !CertainItemSupplier! class is the basic !ItemSupplier!
implementation. Its constructor is called with a supplier ID and set
of valid item IDs. It is assumed that each !CertainItemSupplier! has a
fixed list of valid item IDs that it can supply. Any requests for
other item IDs will result in an !InvalidItemException! being
thrown. Apart from the !InvalidItemException!, we've also implemented
a number of other subexceptions to !OrderProcessingException!, that
make communication and error handling easier.

The !executeStep! method ensures \emph{all-or-nothing atomicity} by
first making sure that all steps have the correct supplier ID, and
that all item IDs are available at that supplier, and finally that the
amount requested is a positive number (it does not make sense to order
zero or a negative number of items). As the !getOrdersPerItem! method
does not modify any data, we are not concerned with all-or-nothing
atomicity; we just have verify that the item IDs are valid before
querying for the amounts.

The !CertainItemSupplier! class also contains a read-write lock, which
is used to ensure before-or-after atomicity of the operations on the
same item supplier: In !executeStep!, the write-lock is acquired after
verifying the supplier and item IDs; in !getOrdersPerItem! it is
acquired after we've verified the item IDs. This ensures
before-or-after atomicity in !CertainItemSupplier!.

Another approach would have been to have individual read-write locks
for each item ID in the item supplier. However, for simplicity and
ease-of-reasoning, we chose to have just one global lock per item
supplier. We assume that, for this system, !executeStep!, and
therefore modifying updates, will be called much more often than
!getOrdersPerItem! (I feel bad for the item supplier where the
opposite is true), so in either case, the locks acquired will most
likely be exclusive ones. For item suppliers which provide many item
IDs and where most incoming orders only request a few different item,
(say, each order only requests 10 different items, and the supplier
has a thousand different items), we expect a much higher latency using
our method, but if each item supplier only has a small amount of different
items, the benefits of the global-lock approach (that is, quick
locking, no matter how many different items are requested) far
outweigh the benefits of locking each individual item.

The item supplier is then made available to clients via an RPC
interface that uses HTTP to transfer request and response objects over
the network, which is implemented in the !ItemSupplierHTTPServer! and
related classes. The HTTP server is called by running the
!startServer! method, supplying a port number, a supplier ID and a set
of valid item IDs~\footnote{It is also possible to run the main method
  from the command-line, simply supply port number, supplier ID and a
  number of valid item IDs. } . Clients then use the
!ItemSupplierProxy! class to interface with the item supplier. That
class is called with an address (``http://127.0.0.1:8080'', for
example) and a corresponding supplier ID. This means that each proxy
only handles communication with a single item supplier.

\paragraph{}

The !CertainOrderManager! class is the basic !OrderManager!
implementation. Its constructor is called with a manager ID and a map
containing ItemSuppliers mapped by their IDs.

The !registerOrderWorkflow! method executes the workflow
asynchronously by launching a special !Worker! class in a separate
thread. The !Worker! class is supplied with a !Workflow!, a simple
container class for data pertaining to a work flow, and tries to run
the steps. All steps are continually tried until they succeed, except
if some unrecoverable error occurs, such as requesting an invalid item
or supplier ID, an invalid quantity or a malformed request. When a
step is successful or failed, the thread writes to a shared !Workflow!
object, which can be queried through the !getOrderWorkflowStatus!
method of !CertainOrderManager!. Since we can assume, cf. the
assignment handout, that we always either get a response from the item
supplier, or that the item supplier actually failed, we are thus using
\emph{at-most-once} RPC semantics between the order manager and item
supplier.

\paragraph{}

Durability is achieved by logging all incoming requests to the
!CertainOrderManager! and !CertainItemSupplier! classes. For these
purposes, a !Logger! class has been implemented. It has a !log! method
(which is !synchronized! in order to avoid interleaving outputs) that
is used to serialize an object to XML and write it to a file on
disk. Each !CertainOrderManager! and !CertainItemSupplier! has a
unique ID that is used to name a log file. For the
!CertainItemSupplier!, the log simply consists of all the !OrderStep!
objects that the !executeStep! method has received: The objects are
simply serialized into XML and appended to the log file (which is
flushed before returning). Similarly for the !List<OrderStep>! objects
that !registerOrderWorkflow! receives. This way, durability is
ensured, and recovery is as simple as reading the requests from the
log and executing them. It should be noted that, for the purposes of
this assignment, any already existing log files are deleted when
starting the !Logger!. Adapting the !CertainItemSupplier! and
!CertainOrderManager! classes to check for and recover from
preexisting log files, however, is a trivial matter.

\paragraph{}

Failure propagation.

\subsection*{Question 2}

%% An ItemSupplier executes operations originated at multiple
%% instances of OrderManager as well as local clients. Describe how
%% you ensured atomocity of the operations. Mention the following:

%% Which method did you use to ensure serializability at each item
%% supplier?

%% Argue for the correctness of your method.

%% Argue for the performance of your model.


\subsection*{Question 3}

%% How would you recover from a failure of an OrderManager or an
%% ItemSupplier? For each of the two scenarios, explain necessary
%% interaction with other components to archieve recovery, how you
%% would use the log, why it is sufficient.


\subsection*{Question 4}

%% Describe your high-level strategy to test your
%% implementation. Mention the following:

%% How you tested execution workflows by the OrderManager, considering
%% asynchronicity of execution.

%% How you tested operations were atomic at the ItemSupplier

%% How you tested error conditions and failures of multiple comonents.


\subsection*{Question 5}

%% Design, describe and execute an experiment that shows how your
%% implementation of a single ItemSupplier behaves as concurrency is
%% increased. Mention: Setup, Results. Also figures.

\end{document}
